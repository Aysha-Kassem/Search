<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ECMAScript</title>
    <style>
       .pages {text-align: center; padding: 10px;}
       .pages a {padding: 20px; text-decoration: none; color: black;}
    </style>
</head>

<body>
    <div class="pages">
        <a href="index.html">ECMAScript</a>
        <a href="API.html">API</a>
    </div>
    <hr>
    <h1>Advantages ECMAScript 2015 in JavaScript</h1>
    <p>1- Arrow Functions: <br>
        Arrow functions provide a shorter syntax for writing function expressions and anonymous functions. They are
        lexically bound to the containing function's scope. <br>
        Arrows are a type of function shorthand that uses the => syntax. They are syntactically equivalent to analogous features in C#, Java 8, and CoffeeScript. They support both statement block bodies and expression bodies that return the expressionâ€™s value. Unlike functions, arrows have the same lexical this as the code around them. <br>
        <code>const add = (a, b) => a + b;</code> <br><br>

        2- Template Literals: <br>
        Template literals are string literals allowing embedded expressions. You can use backticks (`) to create a
        template string. <br>
        <code>const name = 'John'; <br> const message = `Hello, ${name}!`;</code> <br><br>

        3- Destructuring Assignment: <br>
        Destructuring assignment allows us to unpack values from arrays or objects into distinct variables. <br>
        <code>const [a, b] = [1, 2]; <br>
        const person = {name: 'John', age: 30}; <br> 
        const {
            name,
            age
        } = person;</code> <br><br>

        4- Promises: <br>
        Promises are objects that represent the eventual completion (or failure) of an asynchronous operation. <br>
        <code>const promise = new Promise((resolve, reject) => { <br>
            if (success) { <br>
                resolve(result); <br>
              } else { <br>
                reject(error); <br>
              } 
        }); <br>
        promise.then(result => console.log(result)).catch(error => console.log(error));</code> <br><br>

        5- Modules: <br>
        Modules in ES6 provide a way to structure your code into reusable units. <br>
        Native support for modular development with import and export statements. <br>
        <code>export const name = 'John'; <br> export const age = 30; <br>export const pi = 3.14; <br>import { pi } from './module.js';
         </code> <br><br>

        6- Classes: <br>
        Classes in ES6 provide a more concise syntax for creating objects and methods. <br>
        ES6 classes are only an extension of the prototype-based OO design. Having a single accessible declarative form simplifies the usage of class patterns and supports interoperability. Prototype-based inheritance, super calls, instance, and static methods, and constructors are all supported by classes. <br>
        <code>class Person { <br>
            constructor(name, age) { <br>
                this.name = name; <br>
                this.age = age; <br>
            } <br>
            greet() { <br>
                console.log(`Hello, my name is ${this.name}!`); <br>
            }
        } <br>
        const john = new Person('John', 30); <br>
        john.greet();</code> <br><br>

        7- Block-Scoped Variables:
        Let and const provide block-level scope, reducing issues related to variable hoisting and accidental overwriting
        of variables. <br>
        Block-scoped variables let you declare variables with limited scope to their nearest enclosing block. <br>
        <code>if (true) { <br>
            let x = 10; <br>
            const y = 20; <br>
            console.log(x); // Output: 10 
        } <br>
        console.log(x); // Output: ReferenceError: x is not defined</code> <br><br>

        8- Default Parameters:
        Default parameters provide a way to set default values for function parameters. <br>
        <code>function greet(name = 'John') { <br>
            return `Hello, ${name}!`; <br>
        } <br>
        greet(); // Output: Hello, John!</code> <br><br>

        9- Rest and Spread Operators: <br>
        Rest and spread operators allow us to spread elements of an array or an object into a new array or object. <br>
        <code>const numbers = [1, 2, 3, 4, 5]; <br>
        const [first,...rest] = numbers; <br>
        function sum(...args) { <br>
            return args.reduce((a, b) => a + b, 0); <br>
          } <br>
        console.log(first); // Output: 1 <br>
        console.log(rest); // Output: [2, 3, 4, 5]</code> <br><br>

        10- Asynchronous Programming: <br>
        ES6 provides async/await syntax for writing asynchronous code that looks like synchronous code. <br>
        <code>async function greetAsync(name) { <br>
            const response = await fetch(`https://api.example.com/user/${name}`); <br>
            const data = await response.json(); <br>
            return `Hello, ${data.name}!`; <br>
        } <br>
        greetAsync('John').then(message => console.log(message));</code> <br><br>

        11- Object Literals: <br>
        Object literals provide a more concise syntax for creating objects. <br>
        Setting the prototype upon creation, shorthand for foo: foo assignments, creating methods, making super calls, and computing property names using expressions are all supported by object literals. Together, these bring object literals and class declarations closer, giving the object-based design some of the same benefits. <br>
        <code>const person = { <br>
            name: 'John', <br>
            age: 30, <br>
            greet() { <br>
                return `Hello, my name is ${this.name}`; <br>
            }
        }; <br>
        person.greet();</code> <br><br>

        12- Iterators and Generators:
        Iterators and generators allow you to create iterators for custom collections and iterate over them using
        for...of loops. <br>
        <code>const numbers = [1, 2, 3, 4, 5]; <br>
            for (const number of numbers) { <br>
                console.log(number); <br>
            } <br>
            function* generateNumbers() { <br>
                yield 1; <br>
                yield 2; <br>
                yield 3; <br>
                yield 4; <br>
                yield 5; <br>
            } <br>
            const generator = generateNumbers(); <br>
            for (const number of generator) { <br>
                console.log(number); <br>
            }</code> <br><br>
        
        13 - Symbols: <br>
        Symbols are unique values used to identify properties. They are immutable and unique. <br>
        <code>const symbol1 = Symbol(); <br>
        const symbol2 = Symbol(); <br>
        console.log(symbol1 === symbol2); // Output: false</code> <br><br>

        14 - map: <br>
        Maps provide a key-value store. They are similar to objects, but they can have any type of keys and values. <br>
        <code>const map = new Map(); <br>
            map.set('name', 'John'); <br>
            map.set('age', 30); <br>
            console.log(map.get('name')); // Output: John</code> <br><br>

        15 - Set: <br>
        Sets are collections of unique values. They are iterable and can have methods like forEach, map, and filter. <br>
        <code>const set = new Set(); <br>
            set.add(1); <br>
            set.add(2); <br>
            set.add(3); <br>
            console.log(set); // Output: Set { 1, 2, 3, 4 }</code> <br><br>
    </p>
</body>

</html>
